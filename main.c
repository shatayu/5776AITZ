#pragma config(Sensor, in1,    MainLiftPot,    sensorPotentiometer)
#pragma config(Sensor, in2,    MogoPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    TopLiftPot,     sensorPotentiometer)
#pragma config(Sensor, in5,    Gyro,           sensorGyro)
#pragma config(Sensor, in6,    ConePot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LEncoder,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  REncoder,       sensorQuadEncoder)
#pragma config(Motor,  port2,           LDrive,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LMainLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ConeIntake,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LMogoIntake,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RMogoIntake,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           TopLift,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           RMainLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           RDrive,        tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

#include "lift/lift.h"
#include "intake/intake.h"
#include "drive/drive.h"
#include "programs/autostack.h"

#include "lift/lift.c"
#include "intake/intake.c"
#include "drive/drive.c"
#include "programs/autostack.c"

#include "Vex_Competition_Includes.c"
void pre_auton() {
	bLCDBacklight = true;
  //calibrate();
  bStopTasksBetweenModes = true;
}

task autonomous() {
	a.maxHeight = 1240;
	a.scoringHeight = 1240;
	startTask(autostackUp);
	while (a.stacked == false)
		wait1Msec(20);
	abortAutostack();
	startTask(fieldReset);
}

// drive code
task driveControl() {
	while (true) {
		// dead zone
  	int leftPower = (abs(vexRT[Ch3] + vexRT[Ch1]) > 20) ? vexRT[Ch3] + vexRT[Ch1] : 0;
  	int rightPower = (abs(vexRT[Ch3] - vexRT[Ch1]) > 20) ? vexRT[Ch3] - vexRT[Ch1] : 0;

  	// apply power
  	moveDrive(leftPower, rightPower);
  	wait1Msec(20);
	}
}

int conesOnMogo = 0;
int autostackAction = 0;
task usercontrol() {

	// initialize drive code for drive
	startTask(driveControl);

	int clawStall = -15;
  while (true) {
  	// LCD code
  	displayLCDNumber(0, 8, conesOnMogo);

  	// main lift code
  	if (vexRT[Btn5U]) {
  		moveMainLift(127);
  	} else if (vexRT[Btn5D]) {
  		moveMainLift(-127);
  	} else {
  		moveMainLift(0);
  	}

  	// top lift code
  	if (vexRT[Btn8U]) {
  		moveTopLift(127);
  	} else if (vexRT[Btn8D]) {
  		moveTopLift(-127);
  	} else {
  		moveTopLift(0);
  	}

  	// mogo intake code
  	if (vexRT[Btn7U]) {
  		moveMogoIntake(-127); // withdraw mogo intake
  	} else if (vexRT[Btn7D]) {
  		moveMogoIntake(127); // extend mogo intake
  	} else {
  		moveMogoIntake(0); // power mogo intake off
  	}

  	// cone intake (claw) code
  	if (vexRT[Btn6U] && vexRT[Btn6D]) {
  		moveConeIntake(15); // stall torque
  	} else if (vexRT[Btn6U]) {
  		moveConeIntake(70); // close cone intake
  		clawStall = 10;
  	} else if (vexRT[Btn6D]) {
  		moveConeIntake(-70); // open cone intake
  		clawStall = -15;
  	} else {
  		moveConeIntake(clawStall); // stall cone intake in the right direction
  	}

  	wait1Msec(20);
  }
}
